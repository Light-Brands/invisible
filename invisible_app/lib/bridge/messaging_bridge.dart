// NOTE: This bridge wraps auto-generated FFI functions from rust/src/api/messaging.rs
// The actual FFI bindings will be generated by flutter_rust_bridge_codegen in lib/ffi/api/messaging.dart
// Run: cd rust && flutter_rust_bridge_codegen generate

// Uncomment these imports once bindings are generated:
// import '../ffi/api/messaging.dart';

/// Dart wrapper for messaging FFI functions
///
/// Provides a clean interface to Rust-based Signal protocol E2EE messaging.
class MessagingBridge {
  /// Initialize Signal protocol client
  ///
  /// TODO: This connects to invisible-messaging crate for real Signal protocol
  /// For now, returns a placeholder client ID.
  ///
  /// Parameters:
  /// - identityKey: The user's long-term identity key (base64 encoded)
  ///
  /// Returns: Client ID for subsequent messaging operations
  static Future<String> initClient(String identityKey) async {
    // TODO: Uncomment when FFI bindings are generated:
    // return await messagingInitClient(identityKey: identityKey);
    throw UnimplementedError(
      'FFI bindings not generated yet. Run: cd rust && flutter_rust_bridge_codegen generate'
    );
  }

  /// Send encrypted message through Scrambler network
  ///
  /// TODO: Implement full E2EE with Signal protocol + Scrambler routing
  ///
  /// Parameters:
  /// - clientId: Client ID from initClient
  /// - recipientPublicKey: Recipient's public key (base64 encoded)
  /// - message: Plaintext message to encrypt and send
  ///
  /// Returns: Message ID for tracking delivery status
  static Future<String> sendMessage(
    String clientId,
    String recipientPublicKey,
    String message,
  ) async {
    // TODO: Uncomment when FFI bindings are generated:
    // return await messagingSendMessage(
    //   clientId: clientId,
    //   recipientPublicKey: recipientPublicKey,
    //   message: message,
    // );
    throw UnimplementedError(
      'FFI bindings not generated yet. Run: cd rust && flutter_rust_bridge_codegen generate'
    );
  }

  /// Receive new encrypted messages
  ///
  /// TODO: Connect to relay nodes and decrypt messages
  ///
  /// Parameters:
  /// - clientId: Client ID from initClient
  ///
  /// Returns: List of decrypted messages
  static Future<List<dynamic>> receiveMessages(String clientId) async {
    // TODO: Uncomment when FFI bindings are generated:
    // return await messagingReceiveMessages(clientId: clientId);
    throw UnimplementedError(
      'FFI bindings not generated yet. Run: cd rust && flutter_rust_bridge_codegen generate'
    );
  }

  /// Add new contact with X3DH key exchange
  ///
  /// TODO: Implement proper X3DH handshake
  ///
  /// Parameters:
  /// - clientId: Client ID from initClient
  /// - publicKey: Contact's public key (base64 encoded)
  /// - name: Display name for contact
  ///
  /// Returns: Contact object with session details
  static Future<dynamic> addContact(
    String clientId,
    String publicKey,
    String name,
  ) async {
    // TODO: Uncomment when FFI bindings are generated:
    // return await messagingAddContact(
    //   clientId: clientId,
    //   publicKey: publicKey,
    //   name: name,
    // );
    throw UnimplementedError(
      'FFI bindings not generated yet. Run: cd rust && flutter_rust_bridge_codegen generate'
    );
  }

  /// Get all contacts
  ///
  /// TODO: Load contacts from secure storage
  ///
  /// Parameters:
  /// - clientId: Client ID from initClient
  ///
  /// Returns: List of contacts
  static Future<List<dynamic>> getContacts(String clientId) async {
    // TODO: Uncomment when FFI bindings are generated:
    // return await messagingGetContacts(clientId: clientId);
    throw UnimplementedError(
      'FFI bindings not generated yet. Run: cd rust && flutter_rust_bridge_codegen generate'
    );
  }
}
